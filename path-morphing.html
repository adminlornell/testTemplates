<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Path Morphing Animation - Lornell Real Estate</title>
    <style>
        :root {
            --red-primary: #B22222;
            --white: #FFFFFF;
        }
        
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #f5f5f5 0%, #e0e0e0 100%);
            font-family: 'Montserrat', sans-serif;
        }
        
        .animation-container {
            background: var(--white);
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            text-align: center;
            color: var(--red-primary);
            margin-bottom: 2rem;
        }
        
        svg {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <div class="animation-container">
        <h1>Lornell Real Estate</h1>
        <p style="text-align: center; color: #666; margin-bottom: 2rem;">
            Building • Key • Location • Investment • Growth • Partnership • Contracts
        </p>
        <div id="path-morphing-container"></div>
    </div>

    <!-- Load flubber from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/flubber@0.4.2/build/flubber.min.js"></script>
    
    <!-- Load PathMorphing class -->
    <script src="js/path-morphing.js"></script>
    
    <script>
        // Real Estate Related Shape Paths
        const building = "M3 21h18v-2H3v2zm0-4h4v-4H3v4zm6 0h4v-4H9v4zm6 0h4v-4h-4v4zm-12-6h4V7H3v4zm6 0h4V7H9v4zm6 0h4V7h-4v4zm-12-6h18V3H3v2z";
        const key = "M17 8c0-2.76-2.24-5-5-5S7 5.24 7 8c0 1.57.73 2.97 1.86 3.89L3 19.17V22h3.83l5.28-5.28c.92 1.13 2.32 1.86 3.89 1.86 2.76 0 5-2.24 5-5s-2.24-5-5-5zm-5 7c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z";
        const location = "M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z";
        const dollar = "M11.8 10.9c-2.27-.59-3-1.2-3-2.15 0-1.09 1.01-1.85 2.7-1.85 1.78 0 2.44.85 2.5 2.1h2.21c-.07-1.72-1.12-3.3-3.21-3.81V3h-3v2.16c-1.94.42-3.5 1.68-3.5 3.61 0 2.31 1.91 3.46 4.7 4.13 2.5.6 3 1.48 3 2.41 0 .69-.49 1.79-2.7 1.79-2.06 0-2.87-.92-2.98-2.1h-2.2c.12 2.19 1.76 3.42 3.68 3.83V21h3v-2.15c1.95-.37 3.5-1.5 3.5-3.55 0-2.84-2.43-3.81-4.7-4.4z";
        const chart = "M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z";
        const handshake = "M9.5 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm5.5 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zM12 7.5c2.33 0 4.31 1.46 5.11 3.5h1.3c.8-2.05 2.78-3.5 5.09-3.5 1.74 0 3.26.96 4.05 2.38.26-.51.4-1.07.4-1.65 0-2.22-1.78-4-4-4-1.4 0-2.6.72-3.29 1.8C18.6 3.68 17.37 3 16 3c-1.23 0-2.29.7-2.82 1.71-.53-1.01-1.59-1.71-2.82-1.71-1.37 0-2.6.68-3.29 1.8C6.6 3.72 5.4 3 4 3 1.78 3 0 4.78 0 7c0 .58.14 1.14.4 1.65C1.19 7.46 2.71 6.5 4.45 6.5c2.31 0 4.29 1.45 5.09 3.5h1.3c.8-2.04 2.78-3.5 5.11-3.5zM2 14.5c0 1.38 1.12 2.5 2.5 2.5h15c1.38 0 2.5-1.12 2.5-2.5V12H2v2.5z";
        const document = "M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z";
        
        const paths = [building, key, location, dollar, chart, handshake, document];
        const colors = [
            "#fff312",
            "#ff0088",
            "#dd00ee",
            "#9911ff",
            "#0d63f8",
            "#0cdcf7",
            "#4ff0b7"
        ];
        
        // Use Lornell brand colors instead
        const brandColors = [
            "#B22222", // Red primary
            "#8B1A1A", // Red dark
            "#B22222",
            "#8B1A1A",
            "#B22222",
            "#8B1A1A",
            "#B22222"
        ];
        
        let currentPathIndex = 0;
        let animationId = null;
        let progress = 0;
        let isAnimating = false;
        
        const pathElement = document.getElementById('morphing-path');
        
        // Easing function
        function easeInOut(t) {
            return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        }
        
        // Animate between two paths
        function animatePath(fromPath, toPath, duration = 800) {
            if (isAnimating) return;
            isAnimating = true;
            
            const startTime = performance.now();
            const interpolator = flubber.interpolate(fromPath, toPath, {
                maxSegmentLength: 0.1
            });
            
            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const t = Math.min(elapsed / duration, 1);
                const easedT = easeInOut(t);
                
                const currentPath = interpolator(easedT);
                pathElement.setAttribute('d', currentPath);
                
                if (t < 1) {
                    animationId = requestAnimationFrame(animate);
                } else {
                    isAnimating = false;
                    // Move to next path
                    currentPathIndex = (currentPathIndex + 1) % paths.length;
                    if (currentPathIndex === 0) {
                        // Loop back to start
                        currentPathIndex = 1;
                    }
                    setTimeout(() => {
                        animatePath(paths[currentPathIndex - 1], paths[currentPathIndex]);
                    }, 200);
                }
            }
            
            animationId = requestAnimationFrame(animate);
        }
        
        // Initialize
        pathElement.setAttribute('d', paths[0]);
            pathElement.setAttribute('fill', brandColors[0]);
        
        // Start animation after a short delay
        setTimeout(() => {
            animatePath(paths[0], paths[1]);
        }, 500);
        
        // Update color as path changes
        function updateColor() {
            const colorIndex = currentPathIndex % brandColors.length;
            pathElement.setAttribute('fill', brandColors[colorIndex]);
        }
        
        // Enhanced version with color transitions
        function animatePathWithColor(fromPath, toPath, fromColor, toColor, duration = 800) {
            if (isAnimating) return;
            isAnimating = true;
            
            const startTime = performance.now();
            const interpolator = flubber.interpolate(fromPath, toPath, {
                maxSegmentLength: 0.1
            });
            
            // Color interpolation helper
            function hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            }
            
            function rgbToHex(r, g, b) {
                return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            }
            
            function interpolateColor(color1, color2, t) {
                const rgb1 = hexToRgb(color1);
                const rgb2 = hexToRgb(color2);
                const r = Math.round(rgb1.r + (rgb2.r - rgb1.r) * t);
                const g = Math.round(rgb1.g + (rgb2.g - rgb1.g) * t);
                const b = Math.round(rgb1.b + (rgb2.b - rgb1.b) * t);
                return rgbToHex(r, g, b);
            }
            
            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const t = Math.min(elapsed / duration, 1);
                const easedT = easeInOut(t);
                
                // Interpolate path
                const currentPath = interpolator(easedT);
                pathElement.setAttribute('d', currentPath);
                
                // Interpolate color
                const currentColor = interpolateColor(fromColor, toColor, easedT);
                pathElement.setAttribute('fill', currentColor);
                
                if (t < 1) {
                    animationId = requestAnimationFrame(animate);
                } else {
                    isAnimating = false;
                    // Move to next path
                    currentPathIndex = (currentPathIndex + 1) % paths.length;
                    if (currentPathIndex === 0) {
                        currentPathIndex = 1;
                    }
                    const nextIndex = (currentPathIndex + 1) % paths.length;
                    setTimeout(() => {
                        animatePathWithColor(
                            paths[currentPathIndex],
                            paths[nextIndex],
                            brandColors[currentPathIndex % brandColors.length],
                            brandColors[nextIndex % brandColors.length]
                        );
                    }, 200);
                }
            }
            
            animationId = requestAnimationFrame(animate);
        }
        
        // Initialize using PathMorphing class
        if (typeof PathMorphing !== 'undefined') {
            window.pathMorphing = new PathMorphing('path-morphing-container', {
                width: 400,
                height: 400,
                colors: brandColors,
                duration: 1000,
                pauseBetween: 300
            });
        } else {
            // Fallback to inline animation if class not loaded
            setTimeout(() => {
                animatePathWithColor(
                    paths[0],
                    paths[1],
                    brandColors[0],
                    brandColors[1]
                );
            }, 500);
        }
    </script>
</body>
</html>

